## 타입 변환과 단축 평가

---

1. 타입 변환이란?
2. 암묵적 타입 변환
3. 명시적 타입 변환
4. 단축 평가

---

<br/>

### **1. 타입 변환이란?**

- 명시적 타입 변환 : 개발자가 의도적으로 값의 타입을 변환
- 암묵적 타입 변환 : 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 변환됨

### **2. 암묵적 타입 변환**

- 문자열 타입으로 변환

  - - 문자열 연결 연산자로 동작 가능 (피연산자중 하나 이상이 문자열)

  - 템플릿 리터럴의 표현식 삽입

  - Symbol은 문자열로 변환 불가 (TypeError)

- 숫자 타입으로 변환

  - 산술 연산자

  - 비교 연산자

  - - 단항 연산자

    * 빈 문자열, 빈 배열, null, false는 0으로, true는 1로 변환됨

    * 객체와 빈 배열이 아닌 배열, undefined는 NaN

    * Symbol 값은 TypeError

- 불리언 타입으로 변환

  - JS 엔진은 불리언 타입이 아닌 값을 Truthy 값 (참으로 평가되는 값) / Falsy 값 (거짓으로 평가되는 값)으로 구분

  - Falsy 값: false, undefined, null, 0, -0, NaN, '' (빈 문자열)

  - 그 이외는 모두 Truthy 값

### **3. 명시적 타입 변환**

- 문자열 타입으로 변환

  - String 생성자 함수를 new 연산자 없이 호출 (표준 빌트인 생성자 함수)

  - Object.prototype.toString 메서드 사용 (표준 빌트인 메서드)

  - 문자열 연결 연산자 사용

- 숫자 타입으로 변환

  - Number 생성자 함수를 new 연산자 없이 호출

  - parseInt, parseFloat 함수 사용 (문자열만 숫자 타입으로 변환 가능)

  - - 단항 산술 연산자 이용

  - - 산술 연산자 이용

- 불리언 타입으로 변환

  - Boolean 생성자 함수를 new 연산자 없이 호출

  - ! 부정 논리 연산자 두 번 사용 (!!)

### **4. 단축 평가**

- 논리 연산자를 사용한 단축 평가

  - 논리합 또는 논리곱 연산자 표현식은 언제나 2개의 피연산자 중 한쪽으로 평가됨

  - ex) 'Cat' && 'Dog' // 'Dog'

  - 피연산자 타입 변환하지 않고 그대로 반환

  - short-circuit evaluation

    - 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정 생략

    - if 문 대체 가능

      - 조건이 Truthy 값 => 논리곱 연산자 표현식 이용

      - 조건이 Falsy 값 => 논리합 연산자 표현식 이용

  - 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티 참조할 때

    - 논리곱 연산자 사용

    - 좌항 피연산자가 false로 평가되는 Falsy 값(false, undefined, null, 0, -0, NaN, '')이면

      좌항 피연산자 그대로 반환

    - 그렇지 않으면 우항의 프로퍼티 참조

  - 함수 매개변수에 기본값을 설정할 때

    - 논리합 연산자 사용

    - 기본 매개변수 사용 (ES6)

- 옵셔널 체이닝 연산자

  - ES11 (ECMAScript 2020)

  - ?.

  - 좌항의 피연산자가 null 또는 undefined인 경우 undefined 반환, 그렇지 않으면 우항의 프로퍼티 참조

- null 병합 연산자

  - ES11 (ECMAScript 2020)

  - ?? (nullish coalescing)

  - 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자 반환, 그렇지 않으면 좌항의 피연산자 반환

  - 변수에 기본값 설정 시 유용
